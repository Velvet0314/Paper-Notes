# 🚀 四个月 3D 分子生成复现 + 提升代码能力计划
---
# 📋 第1个月：VGAE（入门，PyTorch Geometric）

**目标**：理解图上的 VAE 框架，掌握 **图编码 (GCN) → 潜在空间 z → 图解码 → 重构邻接矩阵** 的基本流程。  
**项目**：[VGAE 示例代码（PyTorch Geometric 官方）](https://github.com/pyg-team/pytorch_geometric/blob/master/examples/autoencoder.py)

---

-  **Week 1：跑通代码 + 数据流向**
	- [ ]  跑通 VGAE 的训练脚本（Cora 引文网络数据集）。
	- [ ]  画出数据流向图（输入图 → GCN encoder → z → inner product decoder → 重建邻接矩阵）。
	- [ ]  确认输入/输出张量的维度（节点特征、邻接矩阵、latent z）。
	- [ ]  整理本周笔记并复盘。
	- [ ]  休息/补缺。
-  **Week 2：论文对照 + loss 理解**
	- [ ]  阅读 VGAE 论文的模型部分（encoder、reparameterization、decoder、loss）。
	- [ ]  在代码中找到 **encoder**（GCN 实现）的对应部分。
	- [ ]  在代码中找到 **reparameterization**（均值 + 方差采样 z）的对应部分。
	- [ ]  在代码中找到 **decoder**（inner product）的对应部分。
	- [ ]  在代码中找到 **loss**（重构 + KL）的对应部分。
	- [ ]  撰写笔记：整理 **“论文公式 ↔ 代码实现”** 对照表。
	- [ ]  复盘总结。
- **Week 3：代码改造 + 最小实现**
	- [ ]  修改代码：限制训练数据集规模（只取 100 个节点/子图）并观察训练过程。
	- [ ]  将 decoder 从 inner product 改为 **MLP**（输入 z，输出邻接概率）。
	- [ ]  实现一个“最小 VGAE”：
	    - [ ] 2 层 GCN encoder
	    - [ ] MLP decoder
	    - [ ] BCE + KL loss
	- [ ]  测试并验证最小 VGAE 的效果。
	- [ ]  整理本周笔记并复盘。
- **Week 4：总结与变体**
	- [ ]  写总结笔记：思考在不看源码的情况下，如何独立实现 VGAE。
	- [ ]  进行实验：将 loss 函数在 **MSE** 和 **BCE** 之间替换，并记录对比收敛效果。
	- [ ]  思考并记录：
	    - [ ] decoder 为什么常用 inner product？它有什么优缺点？
	    - [ ] 如果换成更复杂的解码器（如 GCN decoder），可能会带来什么影响？
	- [ ]  整理本月所有笔记。
	- [ ]  完成拓展任务或休息。

**拓展任务**
	- 用 **PyTorch Geometric** 实现一个 toy VGAE：输入简单图（如环、链、树），验证其重建能力。
	- 将 VGAE 应用到 **小分子图** 数据集：
	    - 使用 RDKit 将 SMILES 字符串转换为分子图。
	    - 将分子图作为 VGAE 的输入，尝试重建其邻接矩阵。
	- 在 latent space (z) 中进行插值（如 `z_new = alpha * z1 + (1-alpha) * z2`），解码生成过渡图，并观察其结构变化。

## **第2个月：JT-VAE（进阶，树+图结构）**

目标：理解分子生成中的 **树结构 + 图结构** 联合建模。  
项目：[JT-VAE](https://github.com/wengong-jin/icml18-jtnn)

- **Week 1：跑通代码 + 结构对比**
    - 跑通 JT-VAE 训练
    - 对比 GraphVAE 和 JT-VAE 代码结构
    - 画模型图（分子分解 → tree encoder + graph encoder → z → decoder）
- **Week 2：论文对照 + 模块定位**
    - 阅读论文：树分解 + 图结构介绍
    - 在代码中找到 tree encoder、graph encoder、decoder
    - 写“论文公式 ↔ 代码函数”笔记
- **Week 3：代码改造 + toy 实验**
    - 改代码：只保留树结构部分，跑 toy 数据
    - 修改生成：限制分子树最大深度，观察生成分子变化
- **Week 4：总结与对比**
    - 笔记：JT-VAE 比 GraphVAE 增强在哪里？（树分解约束 + 图解码）
    - 尝试改训练超参（优化器、学习率），看稳定性

**拓展任务**
- 用 RDKit 写一个**分子分解器**：拆环和支链，对比 JT-VAE 的分解方法
- 复现“只用树” or “只用图”的 ablation 实验
- 思考：JT-VAE 能否迁移到 3D 分子几何信息？

---

## **第3个月：GraphAF（流模型，自回归）**

目标：学习 **Flow-based 自回归生成**，掌握分子逐步生成的思想。  
项目：[GraphAF](https://github.com/DeepGraphLearning/GraphAF)

- **Week 1：跑通代码 + 流程图**
    - 跑通 GraphAF 训练 + 分子生成。
    - 画数据流向图（逐步 autoregressive 生成流程）
- **Week 2：论文对照 + likelihood 理解**
    - 阅读论文 flow transformation 部分
    - 在代码中找到 log-likelihood 计算实现
    - 写“公式 ↔ 代码”对照笔记
- **Week 3：代码改造 + 可视化**
    - 修改生成：限制分子 ≤10 原子
    - 在训练中打印中间分子，做可视化
- **Week 4：toy 自回归生成器**
    - 自己实现一个 toy 版本：
        - 用 RNN 生成字符序列（如化学式字符串）
        - 对比 GraphAF 的逐步生成

**拓展任务**
- 给 GraphAF 增加条件（如控制分子大小）。
- 尝试在 latent space 做插值，生成不同复杂度的分子。
- 思考：GraphAF 的 log-likelihood 如何保证训练稳定？

---

## **第4个月：GeoDiff（前沿，扩散模型）**

目标：掌握 **Diffusion 在分子生成中的应用**，理解最新方法。  
项目：[GeoDiff](https://github.com/MinkaiXu/GeoDiff)

- **Week 1：跑通代码 + diffusion 流程**
    - 跑通 GeoDiff 训练（小数据集）
    - 画 forward / reverse diffusion 流程图
- **Week 2：论文公式 + 代码定位**
    - 阅读 diffusion 数学公式。
    - 对照代码：找到“加噪声”“去噪”实现。
- **Week 3：toy diffusion 实现**
    - 自己写一个 1D toy diffusion：
        - 在 MNIST 上做加噪声 → 去噪。
    - 验证 loss 与训练曲线。
- **Week 4：修改与总结**
    - 改代码：换 loss function 或噪声 schedule。
    - 写总结：
        - diffusion 解决了 GraphAF 的哪些问题？
        - 生成效果对比？

**拓展任务**
- 阅读另一篇分子 diffusion 论文（MolDiffusion/EDM）
- 在 GeoDiff 中实现一个小功能（比如新噪声调度）
- 尝试 3D 分子生成任务，对比 JT-VAE/GraphAF